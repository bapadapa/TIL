# 운영체제

- 컴퓨터 시스템의 `자원`들을 `효율적으로 관리`하여 사용자가 편리하고 효과적으로 사용할 수 있도록 `환경을 제공`하는 여러 프로그램의 모임
- 사용자와 하드웨어간 `인터페이스로 동작`하는 시스템SW
- `프로세스`, `기억장치`, `주변장치`, `파일` 등을 관리하는 기능

## 목적

- `처리능력` 향상, `사용 가능도` 향상, `신뢰도` 향상, `반환 시간` 단축
  1. 처리능력 ( Throughput)
     - 시간내에 처리하는 일의 양
  1. 반환 시간 ( Turn Aropund Time )
     - 의뢰 시간부터 처리가 완료되는 시간
  1. 사용 가능도 ( Availability)
     - 즉시 사용 가능한 정도
  1. 신뢰도 ( Reliability )
     - 문제를 정확히 처리하는 정도

## 기능

- `자원 관리`를한다
- 효율적 관리를 위해 `스케줄링 기능`을 제공
- `인터페이스 제공`
- `HW/NET`를 `관리/제어`한다
- 데이터 `관리 및 공유` 기능 제공

## 종류

### Window

- MS사가 개발한 OS
- 특징
  1. GUI
     - 아이콘 사용 가능
  1. 선점형 멀티태스킹 ( Preemptive Multi-Tasking)
     - 멀티 테스킹을 하면서 `주기억장치 이용 시간을 제어`하여프로그램 문제 발생시 `강제 종료`하여 `자원을 반환`시킴
  1. PnP(Plug and Play)
     - HW등을 `설치시 자동으로 환경 구성`을 해줌
  1. OLE ( Object Linking and Embeddinhg )
     - 응용 프로그램간 `자유로운 연결 및 삽입`을 하여 편집할 수 있다.
  1. 255자의 긴 파일명
     - `\/*?<>|` 를 제외한 문자로 255자까지 파일명 지정 가능
  1. Single-User 시스템
     - 개인 시스템 구축 ( 1인 1PC 독점 사용)
       - Unix등은 여러 사람이 하나의 서버(컴퓨터)에 접속하여 사용함

### Unix

- AT&T 벨 연구소 ,MIT , General Electric이 공동 개발한 운영체제
- `시분할`을 위해 설계된 `대화식 OS`
- 대부분 C로 구현되어 이식성과 장치-프로세스 간 호환성이 높다
- `Multi User`, `Multi Tasking` 지원
- `Tree구조` 파일시스템

### Linux

- 리누스 토발즈가 `UNIX 기반`으로 개발한 OS
- `OPEN SOURCE`이다
- 다양한 플랫폼 `설치/재배포 가능`
- `UNIX 와 완벽 호환`

### MacOS

- 애플 사가 `UNIX 기반`으로 개발한 OS
- 자사 제품만 사용 가능하고, 드라이버 `설치및 삭제`과정이 `단순`하다

### Android

- 구글사에서 개발한 모바일OS
- `OPEN SOURCE`이다
- `자바 및 코틀린`으로 개발

### IOS

- 애플사의 모바일OS
- 자사 제품에 내장된다. / 타사 제품은 사용 할 수 없다

# 기억장치 관리

## 관리 전략

- 보조기억장치의 프로그램 및 데이터를 주기억장치에 적재시키는 시기/위치 등을 지정하여 주기억장치의 공간을 효율적으로 사용하기 위한 것
- 종류
  1. 반입(Fetch)
     - 프로그램/데이터를 `언제` 주기억장치에 적재할 것인지를 결정
       1. 요구 반입 (Demand Fetch)
          - 특정 프로그램/데이터 등의 참조를 `요구할 때 적재`
       1. 예상 반입 (Anticipatory Fetch)
          - 프로그램에 의해 참조될 것을 미리 `예상하여 적재`
  1. 배치(Placement)
     - 프로그램/데이터를 주기억장치의 상에 저장할 `위치`를 결정
       1. 최소 적합 (First Fit)
          - 프로그램/데이터가 들어갈 수 있는 `첫 번째 영역`에 배치
       2. 최적 적합 (Best Fit)
          - `단편화를 가장 적게` 남기는 분할 영역에 배치
            - 단편화
              - 분할된 영역이 데이터 보다 작거나 커서 생기는 빈 공간
       3. 최악 적합( Worst Fit)
          - `단편화를 가장 많이` 남기는 분할 영역에 배치
  1. 교체 (Replacement)
     - 이미 사용되고 있는 영역 중 어느 영역과 교체할 것인지 결정
     - 종류
       - [페이지 교체 알고리즘](###페이지교체알고리즘)

## 주기억장치 할당 기법

### 분류

#### 연속 할당

- 프로그램을 연속으로 할당하는 기법

  - 종류

    1.  단일 분할 할당 기법

        - 주기억장치와 사용자가 `1:1대응`으로 영역을 사용하는 기법
        - 초기 OS에서 주로 사용
        - OS 보호 및 사용자 영역만을 사용하기 위해 `OS영역`과 에 `경계 레지스터`가 사용된다
          - 경계 레지스터
            - 사용자 프로그램이 OS영역에 접근하지 못 하도록 보호하는 레지스터
            - 사용자 영역의 시작 주소를 기억함
        - 프로그램이 작다면, 사용자 영역 낭비가 될 수 있다.
        - 종류
          1. 오버레이(Overlay)
             - CPU보다 큰 사용자 프로그램을 실행시 사용
          1. 스와핑(Swwapping)
             - `CPU를 독점하다`, 다른 프로그램과 `교체`하는 기법

    1.  다중 분할 할당 기법
        1. 고정 분할 할당 기법 / `정적 할당 기법`
           - 프로그램 할당 전 OS가 주기억장치의 사용자 영역을 `고정된 크기로 분할 `후 `준비상태 큐`에서 준비중인 프로그램을 각 영역에 할당하여 수행하는 기법
        1. 가변 분할 할당 기법 / `동적 할당 기법`
           - 프로그램이 주기억장치에 적재시 `필요한 만큼 영역을 분할`하는 기법
           - 정적 할당 기법의 단편화 방지를 위해 사용

#### 분산 할당

- 프로그램을 조각으로 나누어 반산하여 할당하는 기법

  1.  #### 페이징

      - 프로그램과 CPU영역을 동일한 크기로 나눈 후 주기억장치 영역에 적재시켜 실행
      - 프로그램을 나눈 단위 : `Page`
      - Page크기로 나눈 주기억장치의 단위 : `Page Frame`
      - `외부 단편화`는 발생하지 않고, `내부 단편화`는 발생할 수 있다.
      - `주소 변환`시 `페이지 맵 테이블`이 필요
        - 주소 변환
          - `논리 주소`를 `물리 주소`로 변환시키는 작업
      - `페이지 맵 테이블` 사용시 `비용증가`, `처리속도 감소`

  1.  #### 세그먼테이션
      - 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주 기억장치에 적재시켜 실행
      - 프로그램을 `배역/함수` 등 `논리적 크기로 나눈 단위`를 세그먼트라한다
      - 각 세그먼트는 `고유한 이름 및 크기`를 갖는다
      - `기억공간을 절약`하기위해 사용
      - `주소 변환`을 위해 `세그먼트 맵 테이블`이 필요하다
      - `내부 단편화`는 발생하지 않고, `외부 단편화`는 발생할 수 있다.

### 페이지교체알고리즘

- 페이지 부재가 발생하면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법
- 종류
  1. OPT(OPTimal replacement)
     - 앞으로 가장 오래 사용되지 않을 페이지를 교체
     - `페이지 부재 횟수`가 `가장 적게 발생`하는 가장 `효율적인 알고리즘`
  1. FIFO( First In First Out)
     - `선입선출 방식`으로 페이지 교체
     - 이해 및 설계가 간단하다
  1. LRU(Least Recently Used)
     - 최근에 가장 `오랫동안 사용하지 않은` 페이지를 교체
     - 페이지마다` Counter / Stack`을 두어 `오래전에 사용된 페이지 교체`
  1. LUF( Least Frequently Used)
     - 사용 `빈도가 가장 적은` 페이지 교체
     - 사용량이 많으면 교체되지 않고 사용된다.
  1. NUR (Not Used Recently)
     - 최근에 사용하지 않은 페이지를 교체
     - `LRU`의 시간적인 `오버헤드를 줄일 수 있다`.
     - 각 페이지마다 2개의 Bit( `참조 ,변형 비트`)가 사용된다
       - 참조 비트
         - 호출시 1, 미 호출시 0
       - 변형 비트
         - 내용변경시 1, 미 변경시0
  1. SCR( Second Chance Replacement)
     - 가장 오랫동안 `주기억장치에 있던 페이지중 자주 사용되는 페이지 교체 방지`
     - FIFO의 단점을 보완

## 가상 기억장치

- 보조 기억장치의 일부를 주 기억장치처럼 사용한 것
- 주기억장치의 부족한 용량을 큰것 처럼 사용하는 기법
- 프로그램을 블록단위로 나누어 CPU보관 후 프로그램 실행시 요구되는 블록만 CPU에 불연속적으로 할당
- 주기억장치 이용률 및 다중 프로그래밍의 효율을 높임
- 일반적인 구현방법
  1.  [페이징](####페이징)
  1.  [세그멘테이션](####세그먼테이션)

### 기타 관리 사항

- 페이지 크기
  1. 페이지 크기가 `작을 경우`
     - `단편화 감소`, 한 개의 페이지를 CPU로 이동 시키는 `시간이 줄어듦`
     - `불필요한 내용`이 주기억장치에 적재될 확률이 적어` 효육적인 WorkSet 유지가능`
     - `페이지 맵 테이블` `크기가 커지고`, `매핑 속도가 늦어짐`
     - `디스크 접근 횟수가 많아` 전체적 `I/O시간`이 늘어남
  2. 페이지 크가가 `클 경우`
     - `단편화 증가`, 한 개의 페이지를 주기억장치로 이동 시키는 `시간이 늘어남`
     - `페이지 맵 테이블` `크기가 작아지고`, `매핑 속도가 빨라짐`
     - `디스크 접근 횟수가 적어` 전체적 `I/O 효율성이 늘어남`
- Locality

  - 프로세스가 실행되는 동안 주기억장치를 참조시 `일부 페이지만 집중적`으로 참조하는 성질
  - 스레싱 방지를 위해 워킹 `셋 이론의 기반`이 되있다.
  - 가상기억장치 관리 및 캐시 메모리 시스템의 이론적인 근거
  - 종류
    1. 시간 구역성 ( Temporal Locality )
       - 프로세스가 실행되면서 하나의 페이지를 `일정 시간`동안 `집중적`으로 `액세스`하는 현상
    1. 공간 구역성 ( Spatial Locality )
       - 프로세스 실행시 `일정 위치`의 페이지를 `집중적으로 엑세스`

- 워킹 셋 ( Working Set )
  - 프로세스가 `일정 시간` 동안 `자주 참조하는 페이지 집합`
  - 프로그램의 `Locality` 특징을 이용
  - 자주 참조되는 `Working Set` 을 주기억장치에 상주시킴으로써 `페이지 부재/교체` 현상이 `줄어` 프로세스의 기억장치의 `안정성이 높아진다`
- 스레싱 ( Thrashing )
  - 프로세스의 처리시간보다 `페이지 교체에 시간 소요가 많아지는 현상`
  - `다중 프로그래밍` 혹은 `기억장치를 사용하는 시스템`에서` 자주 페이지 부재`가 발생하여 시스템 전체의 `성능이 저하됨`
  - 다중 프로그램은 `특정 시점까지는 CPU 이용률이 증가`하지만, 그 정도가 커지면 `스레싱이 나타나면서 CPU이용율이 급격히 감소`된다.

# 프로세스 개요

- 실행중인 프로그램
- 정의
  1.  PCB를 진 프그로램
  1.  실기억장치에 장되있다
  1.  프로세서가 할됭되고, 디스패치가 가능한 단위
  1.  프로시저가 활동중인 것
      - 작은 프로그램으로 나누어진 프로그램의 단위( 부모프로그램이라고도 부름)
  1.  비동기적 행위를 일으키는 주체
  1.  지정된 결과를 얻기위한 일련의 계통적 동작
  1.  목적 혹은 결과에 따라 발생되는 사건들의 과정
  1.  OS가 관리하는 실행 단뒤
- PCB ( Process Control Block)
  - OS가 프로세스에 대한 중요한 정보를 저장해 놓은것
  - 모든 프로새세는 고유의 PCB가있다
  - 저장된 정보
    - `현재 상태` , `포인터`, `고유 식별자`, `스케줄링 및 프로세스 우선순위`, `CPU 레지스터 정보`, `주기억장치 관리 정보`, `I/O상태 정보`, `계정 정보`
- 상태 전이
  - 시스템에서 존재하는 동안의 상태 변화
    - ![IT위키](https://itwiki.kr/images/thumb/e/e9/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%83%81%ED%83%9C%EC%A0%84%EC%9D%B4%EB%8F%84_%EC%83%81%EC%84%B8.png/500px-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%83%81%ED%83%9C%EC%A0%84%EC%9D%B4%EB%8F%84_%EC%83%81%EC%84%B8.png)
  - 상태
    1. 제출 ( Submit )
       - 작업 처리를 위해 작업을 `시스템에게 제출`한 상태
    1. 접수 ( Hold )
       - 작업이 `디스크(스풀공간)에 할당`된 상태
    1. 준비 ( Ready)
       - 프로세스가 `프로세서`를 `할당받기 위해` 기다리고 있는 상태
    1. 대기/블록 ( Wait / Block)
       - 프로세서가` I/O 처리`가 필요하면 현재 실행중인 `프로세스가 중단`되고, `I/O처리가 완료될때까지 대기`
    1. 종료 ( Terminated)
       - 실행 종료 후 `프로세스 할당이 해제`된 상태
  - 관련 용어
    1. Dispatch
       - 준비 상태에서 대기하던 프로세스 하나가 프로세스를 할당받아 실행 상태로 전이하는 과정
       - `준비상태 -> 실행상태`
    1. Wake Up
       - I/O 작업 후 프로세스가 대기상태에서 준비 상태로 전이하는 과정
       - `대기상태 -> 준비상태`
    1. Spooling
       - 처리 속도향상을 위해 데이터를 직접 I/O장치에 보내지 않고, 한번에 보내기위해 디스크에 저장하는것
    1. 교통량 제어기 ( Traffic Controller)
       - 프로세스 상태 조사 및 통보
- 쓰레드 ( Thread )
  - 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위
  - `1개는 단일 스레드`, `n개는 다중 스레드`라부름
  - 프로세스의 `일부 기능`을 갖고 있어 `경량 프로세스`라고도 부른다
  - `독립적인 스케줄링`의 `최소 단위`로서 프로세스 역할을 담당

# 스케줄링

- 시스템의 여러 자원을 해당 프로세스에게 할당화는 작업
- 종류
  1.  장기 스케줄링
      - 어떤 프로세스가 `시스템 자원을 차지`할 수 있도록 할 것인가를 결정하여 `준비상태 큐`로 보내는 작업
  2.  중기 스케줄링
      - CPU 할당받을 `프로세스 결정`
  3.  단기 스케줄링
      - CPU 할당받는 `시기` 및 `특정 프로세스`를 `지정`하는 작업
- 목적
  1.  공정성
      - 모든 프로세스가 `공정하게 할당함`
  1.  처리율 증가
      - 단위 `시간당 프로세스 처리율`을 증가
  1.  CPU 이용률 증가
      - CPU가 `순수`하게 프로세스 `실행시간`을 늘림
  1.  우선순위 제도
      - `우선순위`가 `높은 프로세스 우선 실행`
  1.  오버헤드 최소화
  1.  응답 시간 최소화
      - 작업 지시 및 반응하기 시작하는 시간을 최소화
  1.  대기 시간 최소화
      - 프로세스가 `준비상태 큐`에서 `대기하는 시간 최소화`
  1.  균형있는 자원의 사용
      - 메모리,I/O장치 등의 `자원을 균형 있게 사용`
  1.  무한 연기 회피
      - 자원 사용을 위한 `무한정 연기 상태 회피`
- 비선점 스케줄링
  - 이미 `할당된 CPU`를 다른 프로세스가 `강제로 빼앗아가지 못하는 스케줄링`
  - 프로세스가 할당받으면 프로세스가 완료할때까지 CPU선점ㅎ ㅏㅁ
  - 응답시간 예측이 용이
  - 일괄처리에 적합
  - 종류
    - FCFS, SJF , 우선순위 ,HRN 기한부...
- 선점 스케줄링
  - `우선순위가 높은` 프로세스가 `CPU를 강제로 뺏어`가 사용하는 스케줄링
  - 우선순위에 따라 프로세스 처리
  - 주로 `대화식 시분할 시스템`에 사용
  - `많은 오버헤드 초래`
  - 종류
    - Round Robin, SRT, 선점 우선순위, 다단계 큐, 다단계 피드백 큐....

# 스케줄링 알고리즘

1. FCFS ( First Come First Service)
   - 준비상태 큐에 `도착한 순서`에 따라 CPU 할당
   - 대기시간
     - 프로세스가 대기한 시간
   - 반환 시간
     - 실행시간 + 대기시간
1. SJF ( Shortest Job First)
   - 준비상태 큐에서 `실행시간이 가장 짧은` 프로세스에게 먼저 CPU 할당
   - 평균 대기 시간측면에서 최적 알고리즘이다.
1. HRN ( Hightest Response-ratio Next)
   - 대기시간과 실행 시간을 이용하는 기법
   - `우선순위` 계산 후 숫자가 가장 높은 것 부터 `낮은것으로 순위` 부여
   - 식
     (대기시간 + 서비스 시간) / 서비스 시간

# 환경 변수

- 시스템 소프트웨어의 동작에 영향을 미치는 동적인 값들의 모임
- 변수명 및 값으로 구성
- 시스템 기본 정보 저장
- 자식 프로세스에 상속
- `시스템 환경변수` ( 전역 ), `사용자 환경변수`( 지역)로 구분
- 확인
  1.  window
      - 앞뒤에 `%`를 입력
        - 예시 : %PATH%
      - set을 입력하면 모든 환경변수 값 확인
  1.  UNIX/LINUX 환경변수
      - 앞에 `$` 를 입력하여 사용
      - set, env, printenv, setenv 를 입력하여 값 확인

# 운영체제 기본 명령어

- Window
  1.  dir ( 파일 목록 표시 )
  1.  copy ( 파일 복사 )
  1.  del ( 파일 삭제 )
  1.  type ( 파일 내용 표시 )
  1.  ren ( 파일명 변경 )
  1.  md ( 디렉토리 생성 )
  1.  cd ( 경로 변경 )
  1.  cls ( 화면 내용 삭제 )
  1.  attrib ( 파일 속성 변경)
  1.  find ( 파일에서 문자열 검색 )
  1.  chkdsk ( 디스크 상태 확인 )
  1.  format ( 디스크 상태 점검 )
  1.  move ( 파일 이동 )
- Unix/Linux
  1.  cat ( 파일내용 표시)
  1.  cd ( 경로 이동 )
  1.  chmod ( 파일 권한 변경 )
  1.  chown ( 파일 소유자 및 그룹 변경)
  1.  cp ( 파일 복사)
  1.  rm ( 파일 삭제)
  1.  find ( 파일 검색 )
  1.  fsck ( 파일 시스템 검사 및 보수 )
  1.  kill ( pid를 이용한 프로세스 종료)
  1.  fork ( 프로세스 생성 )
  1.  killall ( 프로세스 명을 이용한 종료)
  1.  ls ( 파일 목록 표시 )
  1.  mkdir ( 디렉토리 생성 )
  1.  rmdir ( 디렉토리 삭제 )
  1.  mv ( 파일 이동 )
  1.  ps ( 실행중인 프로세스 목록 )
  1.  pwd ( 작엽 디렉토리 경로 확인)
  1.  top ( 메모리 사용 현황 확인)
  1.  who ( 현재 접속중인 사용자 확인 )

# 인터넷 ( Internet)

- 컴퓨터 및 네트워크들이 연결된 컴퓨터 통신망

## IP 주소

- 인터넷에 연ㄷ결된 컴퓨터의 자원 구분을 위한 고유 주소
- 8bit 4개로 구성됨
- 구성
  - A Class
    - 국가 및 대형 통신망에 사용 (0~127로 시작)
    - 2^24 개의 호스 사용 가능
  - B Class
    - 중대형 통신망에 사용 (128~191로 시작)
    - 2^& 16 개의 호스트 사용 가능
  - C Class
    - 소규모 통신망에 사용 ( 128~223로 시작)
    - 2^8 개의 호스트 사용 가능
  - D Class
    - 멀티케스트용으로 사용 (224~239로 시작)
  - E Class
    - 실험적 주소 이며 공용되지 않음

## 서브넷팅

- 네트워크 주소를 다시 여러개의 작은 네트워크로 사용하는 것
- IP주소를 `네트워크 - 호스트` 주소로 구분하기 위한 비트가 서브넷 마스크다.

## IPv6

- `IPv4의 주소 부족을 해결`하기 위한 IP주소 체계
- `인증성` , `기밀성` ,`무결성`의 지원으로 `보안문제 해결`
- 주소의 `확장,융통,연동성`이 뛰어나다
- `실시간 흐름제어`로 향상된 멀티미디어 기능을 지원
- `패킷 크기에 제한이 없다`
- `확장 헤더`를 더하여 더욱 다양한 정보 저장이 가능하여 `네트워크 기능 확장이 용이`
- IP v4와 호환성이 좋다
- 구성
  - 16bit \* 8 , 총 128bit
  - 16진수 표기, `:`으로 구분
  - 주소 체계
    1. 유니케스트
       - 1:1통신
    1. 멀티케스트
       - 1:n 통신
    1. 애니케스트
       - 1:1통신
       - 단일 사용자와 가장 가까이 있는 단일 수신자 간의 통신

## 도메인 네임

- IP주소를 문자 형태로 표현한 것
- `컴퓨터이름` -> `소속기관 이름` -> `소속기관 종류` -> `소속국가명` 순으로 표기
  - `왼쪽에서 오른쪽으로 갈수록 상위 도메인`
- `DNS`를 통하여 `도메인 네임`을 `IP주소`로 변경

# OSI 참조모델

- ISO에서 제안한 통신 규약
- OSI 7계층 (하위 : 1~3, 상위 : 4~7)
  1. 물리 계층 ( Physical Layer )
     - `전기적` ,`기계적` ,`기능적` ,`절차적` 특성에 대한 규칙
     - 물리적 정속 매체와 전송 신호 방식 정의
     - RS-232C , X.21등
     - 장비
       - `리피터, 허브`
  1. 데이터 링크 계층 ( Data Link Layer)
     - 송/수신 촉도 차이를 해결을 위한 `흐름제어 기능`
     - 프레임의 시작/끝을 구분하기 위한 `프레임 동기화` 기능
     - 오류 검출/회복을 위한 `오류제어`
     - 프레임의 순차 전송을 위한 `순서 제어` 기능
     - HDLC, LAPB, LLC, MAC, LAPD, PPP등 표준이 있다.
     - 장비
       - `랜카드, 브리지, 스위치`
  1. 네트워크 계층 ( Network Layer)
     - 개방 시스템 간의 네트워크 연결을 `관리하는 기능` 및 `데이터의 교환 및 중계 기능`
     - 네트워크 연결을 `설정, 유지, 해제`하는 기능
     - 경로 설정, 데이터 `교환 / 중계`, `트래픽 제어`, `패킷정보 전송`
     - X.25, IP등
     - 장비
     - `라우터`
  1. 전송 계층 ( Transprot Layer )
     - 종단 시스템간 투명한 데이터 전송 가능
     - `하위 3계층`과 `상위 3계층`의 `인터페이스` 담당
     - 종단 시스템간 `전송연결 설정`, `데이터 전송`, `연결 해제` 기능
     - `주소 설정`, `다중화`, `오류제어`, `흐름제어` 수행
     - TCP , UDP 등
     - 장비
       - 게이트웨이ㅂ
  1. 세션 계층 ( Session Layer)
     - 송수신간 관련성 유지 및 대화 제어 담당
     - 대화 구성 및 동기제어, 데이터 교환관리 기능
     - 동기점 : 데이터 회복을 위해 사용
       1. 소동기점
          - 대화 단위 내에서 데이터 전달을 제어하는 역할, 수신 측으로부터 확인 `신호를 받지 않음`
       2. 대동기점
          - 전송하는 각 데이터의 첫/끝에 사용하여 전송하는 단위를 대화 단위로 구성하는 역할, 수신측으로부터 `확인 신호 받는다`
  1. 표현 계층 ( Presentation Layer )
     - 데이터를 계층에 맞게 변환하는 기능
       - 응용 -> 세션, 세션 -> 응용
     - 상호 접속을 위해 필요한 계층
     - `코드변환`, `데이터암호화`, `데이터 압축`, `구문 검색`, `정보형식 변환`, `문맥관리`
  1. 응용 계층 (Application Layer)
     - 사용자가 OSI 환경에 접근할 수 있도록 서비스 제공
     - `응용 프로세스`간 `정보 교환`, `전자 사서함`, `파일 전송`, `가상 터미널` 등 서비스 제공

## 네트워크 장비

1. 네트워크 인터페이스 카드 (NIC, Network Interface Card)
   - `컴퓨터- 컴퓨터`, `컴퓨터-네트워크`를 연결해주는 장치
   - `케이블`을 통해 송송될 수 있도록 정보 형태를 변경
   - `이더넷 카드` 혹은 네트워크 어댑터라고도 한다
1. 허브 (Hub)
   - LAN을 관리하는 장치로, 각 `회선을 통합 관리`한다
   - 리피터 역할을 포한한다
   - 종류
     1. 더미 허브 (Dummy Hub)
        - `단순히 연결`만 하는 허브
     1. 스위칭 허브( Switchinh hub)
        - 데이터 유무 및 흐름제어를 하여 각 노드가 허브의 `최대 대역폭`까지 `사용 가능`하게 하는 지능형 허브
1. 리피터
   - `수신 신호를 재생` 혹은 `출력 전압을 높여` 전송하는 장치
   - `물리계층`에서 동작하는 장비다.
1. 브리지(Bridge)
   - `Lan-Lan` 연결 혹은 Lan안의 그룹을 연결하는 장치
   - 네트워크의 `트래픽 병목 현상을 줄일 수 있다`.
   - 네트워크를 `분산적으로 구성`할 수 있어 `보안성을 높일 수 있다`.
   - 서브넷 구성시 전송 가능한 회선 수
     - n = 브리지 , `n(n-1)/2` 개
1. 스위치 (Switch)
   - `LAN -Lan` 연결로 더 `큰 LAN`을 만드는 장치
   - `HW기반`이기 때문에 `전송 속도가 빠르다`
   - `Port별 속도 제한`을 할 수 있다.
   - `데이터 링크` 계층에서 사용
1. 라우터 ( Router)
   - `Lan-Lan` 연결시 데이터 전송의 `최적 경로 선택`을 하게 해주는 장치
   - `Lan - Wan`도 연결 가능하다
   - `네트워크 계층`에서 동작
   - 네트워크 계층까지 프로토콜 구조가 다른 `네트워크 간`의 연결을 위해 `프로토콜 변환` 수행
1. 게이트웨이(Gateway)
   - 프로토콜 구조가 다른 네트워크를 연결하는 장치
   - `Lan - Network` 사이에서 데이터를 `송수신하는 출입구` 역할을함
   - `세션, 표현,응용` 계층간 연결하여 `데이터 형식 변환`, `주소 변환`, `프로토콜 변환` 등을 수행

# TCP/IP

## 프로토콜

- 데이터 교환을 원활히 수행하도록 표준화시킨 통신규약
- 기본 요소
  1.  구문 (Syntax)
      - 데이터의 `형식, 부호화, 신호레벨` 등을 규정
  1.  의미 (Semantics)
      - 기기간 `효율 / 정확`한 `정보 전송`을 위한 `협조사항 및 오류관리`를 위한 제어 정보 규정
  1.  시간 (Timing)
      - `기기간 통신속도 `, `메시지 순서제어` 등

# 서버 프로그램 구현

## 개발환경 구축

- 개발 프로젝트를 이해하고 `SW/HW 장비`를 구축하는 것
- 개발 환경은 실제로 `운영될 환경`과 `유사한 구조`로 구축
- `분석 단계의 산출물을 바탕`으로 개발에 필요한 `SW/HW 를 선정`
- 비지니스 환경에 적합한 제품들을 결정하여 구축

## HW 환경

- 클라이언트 - 서버 로 구성
- 종류 : PC, 스마트폰 ,테블릿 , 등
- 종류
  1. 웹 서버 (Web Server)
     - 클라이언트로부터 작업을 받아 처리
     - 저용량 정적 파일 제공
       - 정적 파일 : 추가 가공이 필요 없는 파일
  2. 웹 어플리케이션 서버 (WAS)
     - 동적 서비스 제공
     - WEB/DB/FILE 서버 사이의 `인터페이스 역할` 수행
  3. 데이터베이스 서버 (DB Sever)
     - DB관리하는 DBMS 운용
  4. 파일 서버 (File Server)
     - `DB에 저장`하기엔 `비효율`이거나 `서비스 제공 목적`인 파일들을 저장

## SW 환경

- 클라이언트/ 서버 운영 및 개발에 사용되는 SW로 구성
- 시스템 SW 종류 : `OS`, `WAS`, `DBMS`....
- 개발 SW 종류

  1. 요구사항 관리도구
     - `수집/분석/추적`등을 도와주는 소프트웨어
  2. 설게/모델링 도구
     - `UML`을 지원하며, `개발 전 과정`에서 `설계 및 모델링`을 도와주는 SW
  3. 구현 도구
     - 실제 개발을 하는 SW
  4. 빌드 도구
     - `빌드/배포/라이브러리` 관리 등을 지원하는 SW
  5. 테스트 도구

     - 요구사항에 적합하게 구현하였는지 테스트하는 SW

  6. 형상 관리 도구
     - 버전 관리를 하여 품질 향상을 지원하는 SW

## 웹 서버 기능

1. HTTP/HTTPS 지원
   - 브라우저 요청 응답시 사용하는 프로토콜
2. 통신 기록 (Comunication Log)
   - 처리한 요청을 `로그 파일로 기록`
3. 정적 파일 관리 (Managing Static Files)
   - 정적 파일 `저장 관리`
4. 대역폭 제한(Bandwidth Throttling)
   - 트래픽 포화를 방지하기 위해 응답 속도 제한
5. 가상 호스팅 (Virtual Hosting)
   - `1개 서버`를 `여러개 도메인 명`으로 연결
6. 인증(Authentication)
   - 사용자 확인 기능

## 개발 언어 선정 기준

1. 적정성
   - 목적이 적합한가
2. 효율성
   - 개발이 효율적인가
3. 이식성
   - `다양한 시스템/환경`에 적용이 가능한가
4. 친밀성
   - 개발자의 `이해도` 및 `활용도`가 높은가
5. 범용성
   - `개발 사례`가 있고, `여러 분야에서 활용`되는가

# 소프트웨어 아키텍처

- 소프트웨어를 구성하는 `요소들 간의 관계`를 표현하는 `시스템의 구조` 또는 `구조체`
- 어플리케이션 분할방법 및 분할된 모듈에 `할당될 기능`, `모듈간 인터페이스` 등을 결정
- 기본 원리

  1. 모듈화
     - `수정`, `재사용`, `유지관리` 등을 위해 시스템의 기능들을 `모듈 단위`로 나누는 것
       - 모듈 : `특정 기능을 처리`할 수 있는 코드
     - 모듈을 너무 `세분화`하여 나누면 `통합 비용`이 많이 든다.
     - 모듈 크기가 크면 `통합비용은 낮아`지지만, `모듈 개발 비용이 많이` 든다.
  2. 추상화

     - 전체적 개념을 설계 후 구체화 시켜나가는 것
     - 시스템 구축 전에 테스트 해볼 수 있다.
     - 유형
       1. 과정 추상화
          - `흐름만 파악`할 수 있게 설계하는 방법
       2. 데이터 추상화
          - 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
       3. 제어 추상화
          - 여러개의 기계어 명령들을 간단히 요약한 것

  3. 단계적 분해
     - `상위의 중요 개념`에서 `하위의 개념으로 구체화` 시키는 기법
  4. 정보 은닉
     - 모듈 내부에 포함된 절차 및 자료들의 정보에 다른 모듈이 `접근/변경`을 `방지`하는 기법
     - 변경시 다른 모듈에 영향을 미치지 않아 `수정/시험/유지보수`가 용이

## 상위 설계 및 하위 설계

- 상위 설계
  - 별칭 : 아키텍처/ 예비 설계
  - 대상 : SYS의 전체적 구조
  - 세부 목록 : 구조, DB, 인터페이스
- 하위 설계
  - 별칭 : 모듈/상세 설계
  - 대상 : 시스템 내부 구조 및 행위
  - 세부 목록 : 컴포넌트, 자료구조, 알고리즘

## 품질 속성

- SW아키텍쳐가 요구 수준의 품질을 유지/보장 할 수 있게 설계되었는지 확인하는 요소들
- 종류
  1. 시스템 측면
     - `성능`, `보안`, `가용성`, `사용성`, `변경 용이성`, `확장성` ...
  2. 비니지스 측면
     - `시장 적시성`, `비용과 혜택`, `예상 시스템 수명`, `목표시장`, `공개 일정` ...
  3. 아키텍쳐 측면
     - `개념적 무결성`, `정확성`, `완결성`, `구축 가능성`, `변경성`, `시험성` ...

## 설계 과정

1. 설계 목표 설정
   - 요구사항 분석 후 전체 시스템 설계 목표 설정
2. 시스템 타입 결정
   - `시스템/서브시스템` 타입 결정 후 `아키택처 패턴 선택`
3. 아키텍처 패턴 적용
   - 시스템 표준 아키텍처 설계
4. 서브시스템 구체화
   - `서브시스템 기능` 및 `상호작용`을 위한 동작 인터페이스 정의
5. 검토
   - `설계 목표`, `요구사항`, `기본 원리` 등을 만족여부 검토

## 협약에 의한 설계

- `컴포넌트 설계`시 클래스에 대한 여러 가정을 `공유` 할 수 있도록 명세
- 조건
  1. 선행 조건(Precondition)
     - 오퍼레이션 `호출 전 참(True)`이 되야할 조건
  2. 결과 조건(Postcondition)
     - 오퍼레이션 `수행 후 만족`해야할 조건
  3. 불변 조건(Invariant)
     - 오퍼레이션 `실행중 만족`해야할 조건

# 아키텍처 패턴

- 아키텍쳐 `설계시 참조`할 수 있는 전형적인 `해결 방식` 혹은 `예제`
- 종류

  1. 레이어 패턴 (Layers Pattern)

     - 시스템을 `계층 구분`하여 구성하는 고전적 패턴
     - `상위 : 서비스 제공자` , `하위 : 클라이언트`
     - 인접 계층만 상호작용 발생
     - 대표 : OSI 참조 모델

  2. 클라이언트-서버 패턴 (Client-Server Pattern)
     - `1개의 서버` 컴포넌트, `다수의 클라이언트` 컴포넌트로 구성된 패턴
       - 1:N구조
     - `사용자` -> `클라이언트` -> `서버` -> `클라이언트` -> `사용자` 순으로 요청이 이루어짐
  3. 파이프-필터 패턴(Pipe-Filter Pattern)
     - `데이터 스트림 절차`의 단계를 `필터로 캡슐화`하여 `파이프를 통해 전송`하는 패턴
     - `데이터 변환`, `버퍼링`, `동기화` 등에 주로 사용
     - 대표 : UNIX SHELL
     - source `-pipe->` filter `-pipe->` fileter `-pipe->` sink
  4. MVC 패턴 (Model-View-Controller Pattern)

     - 서브시스템을 MVC로 구조화 하는 패턴
     - `컨트롤러` : 사용자 요청 받기
       - `INPUT / 제어 / 갱신`
     - `모델` : 핵심 기능 및 인계받은 데이터 보관
       - `저장 / 변경 알림`
     - `뷰` : 정보 출력
       - `OUTPUT / 정보 요청`
       - 여러개 생성 가능
     - 모델 1 : 뷰 n개 의 `대화형 APP`에 적합하다.

  5. 마스터 슬레이브 패턴 ( Master Slave Pattern)
     - 슬레이브에서 처리된 결과를 다시 돌려받는 방식으로 수행하는 패턴
       - `장애 허용 시스템`, `병렬 컴퓨팅 시스템`
  6. 브로커 패턴 ( Broker Pattern )
     - `사용자 요구`를 브로커 컴포넌트에 `요청시` 그에 맞는 `컴포넌트와 연결`해주는 패턴
       - 분산 환경 시스템
  7. P2P 패턴 (Peer to Peer Pattern)
     - 각 컴포넌트가 서버가 될 수 있고, 클라이언트가 될 수 있는 패턴
       - 파일 공유 네트워크
  8. 이벤트 버스 패턴 ( Event Bus Pattern)
     - 채널을 구독한 리스너들이 메시지를 받아 이벤트 처리하는 패턴
       - 알람 서비스
  9. 블랙보드 패턴 (Blackboard Pattern )
     - `모든 컴포넌트`가 `공유 데이터 저장소` 및 `블랙보드 컴포넌트`에 `접근 가능`한 패턴
       - 음성 인식, 차량 식별, 신호 해석
  10. 인터프리터 패턴 (Interpreter Pattern)

      - 코드의 각 라인을 수행하는 방법 지정 및 기호마다 클래스를 갖도록 구성된 패턴
        - 번역기, 컴파일러, 인터프리터

# 객체 지향 (Object Oriented)

- `객체 생성` 후 `객체를 조립`하여 SW 를 개발하는 기법
- `재사용성` 및 `확장`이 용이하여 SW를 `개발` 및 `유지보수`가 쉽다
- 구성요소
  1. 객체 (Object)
     - 데이터 및 함수를 묶어놓은 SW 모듈
       - 데이터 : 객체의 `정보` / `속성` / `상태` / `분류`...
       - 함수 : 데이터 처리하는 `알고리즘` 및 객체 상태 `참조` 및 `변경`하는 수단
  2. 클래스(class)
     - 공통된 `속성` 및 `연산`을 갖는 객체 집합
     - 클래스 내부의 객체를 `인스턴스`라고 부른다
  3. 메시지(message)
     - 객체간 `상호작용에 사용`되는 수단, 객체의 `동작` 및 `연산`을 발생시키는 `외부의 요구` 사항
- 특징
  1. 캡슐화(Encapsulation)
     - 외부 접근을 제한하기 위해 인터페이스를 제외한 `세부 내용을 은닉`하는 것
     - `인터페이스가 단순`해지고, 객체간 `결합도가 낮아`진다.
  2. 상속(Inheritance)
     - 상위 클래스를 하위 클래스가 물려받는 것
  3. 다형성(Polymorphism)
     - 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력
     - 객체는 `동일 메소드명` , `동일 의미의 응답`
  4. 연관성(Relationship)
     - 2개 이상의 객체가 상호 참조하는 관계
     - 종류
       1. is member of
          - 연관화(Association)
          - 2개 이상의 객체가 상호 관련됨
       2. is instance of
          - 분류화(Classfication)
          - `동일형의 특성`으로 객체를 모아 구성
       3. is part of
          - 집단화(Aggregation)
          - `관련된 객체`를 묶어 상위 객체를 구성
       4. is a
          - 일반화(Generalization)
            - `공통 성질`로 `추상화`하여 상위 객체 구성
          - 특수/상세화(Specialization)
            - `상위 객체`를 구체화 하여 `하위 객체를 구성`

## 분석 및 설계

### 객체지향 분석 OOA

- `사용자 요구사항`과 관련된 `객체`, `속성`, `연산`, `관계` 등을 정의하여 모델링
- `객체-속성`, `클래스-멤버`, `전체-부분` 등으로 나누어 분석
- 클래스 식별이 목적

#### 방법론

1. Rumbaugh 방법 (OMT (Object-Modeling Technique) 라고조 부름)
   - `객체`, `동적` , `기능` 모델로 나누어 분석 활동을 함
   - 모든 `SW 구성 요소`를 `그래픽 표기법`을 이용하여 모델링함
   - 활동 순서
     1. 객체 모델링 <정보 모델링>
        - `속성`, `연산 식별` 및 `객체들 간의 관계`를 `객체 다이어그램`으로 표시
     2. 동적 모델링
        - 시간의 흐름에 따라 `동적인 행위`를 `상태 다이어그램`을 이용하여 표현
     3. 기능 모델링
        - 프로세스간 자료흐름 중심으로 `처리과정`을 `DFD(자료흐름도)`를 이용하요 표현
2. Booch 방법
   - `미시/거시적 개발 프로세스` 모두 사용
   - `클래스/객체` 를 분석 및 식별 및 클래스 `속성,연산`을 정의
3. Jacobson 방법
   - `유스케이스`를 강조하여 사용
4. Coad & Yourdon 방법
   - `E-R다이어그램`을 사용하여 `객체 행위 모델링`함
   - `객체 식별`, `구조 식별` ,`주제 정의`, `속성 및 인스턴스 연결 정의`, `연산 및 메시지 연결 정의` 등의 과정
5. Wirfs-Brock 방법
   - `분석과 설계간 구분이 없고` 고객 `명세서를 평가`하여 `설계 작업까지 연속적`으로 수행

### 설계 원칙

- `변경` 혹은 `확장`에 `유연한 시스템`을 `설계`하기 위해 지켜야할 원칙
- 5가지 원칙의 앞글자를따 SOLID원칙이라 부른다
  1. 단일 책임 원칙(SRP)
     - 객체는 1개의 책임만 가져야한다
  2. 개방-폐쇄 원칙(OCP)
     - `코드의 변경 없이 기능 추가`가 가능해야한다
  3. 리스코프 치환 원칙(LSP)
     - 자식 클래스는 부모 클래스의 기능을 수행 할 수 있어야한다
  4. 인터페이스 분리 원칙(ISP)
     - `사용하지 않은 인터페이스`와 `의존관계 혹은 영향을 받지 않아야한다`
  5. 의존 역전 원칙(DIP)
     - 의존 관계 성립 시 `추상성이 높은 클래스`와 `의존 관계`를 맺어야 한다.

# 모듈

- 모듈화를 통해 분리된 시스템의 각 기능
  - 모듈화
    - 시스템의 기능향상을 위해 모듈 단위로 분해하는 것
  - `서브루틴` ,`서브시스템` ,`SW내의 프로그램` , `작업 단위`등을 의미함
- 독립은 결합도와 응집도에 의해 측정됨

1. 결합도 ( Coupling )
   - 모듈 상호간의 `의존정도`
   - 종류 및 강도 ( 아래로 갈수록 약해짐)
     1. 내용 결합도 ( Content Coupling )
        - 다른 모듈의 기능 및 자료를 직접 참조
     2. 공통 결합도 ( Common Coupling )
        - `공통 데이터`를 `여러 모듈`이 사용
     3. 외부 결합도 ( External Coupling )
        - `내부 데이터`를 `외부 모듈에서 참조`
     4. 제어 결합도 ( Control Coupling )
        - 다른 모듈의 내부 몬리 흐름을 제어를 위해 제어 신호 혹은 제어 요소를 전달
        - 하위가 상위를 제어하는 `권리 전도 현상`이 발생할 수 있다
     5. 스탬프 결합도( Stamp Coupling )
        - `상호간 인터페이스`로 배열 등 `자료구조가 전달`됨
     6. 자료 결합도 ( Data Coupling )
        - `상호간 인터페이스`가 `자료 요소`로만 구성
2. 응집도 ( Cohesion )

   - 내부 요소들이 `서로 관련`되어 있는 정도
   - 종류 ( 아래로 갈수록 약해짐)
     1. 기능적 응집도 ( Functional Cohesion )
        - 내부의 `모든 기능 요소`가 `단일 문제와 연관`되어 수행
     2. 순차적 응집도 ( Sequential Cohesion )
        - `내부` 활동의 출력 `데이터`가 `다음 활동 입력 데이터`로 사용함
     3. 교환적 응집도 ( Communication Cohesion )
        - `동일 입력` / `다른 기능`으로 구성됨
     4. 절차적 응집도 ( Procedural Cohesion )
        - 관련 기능의 `여러 모듈`이 `순차적으로 수행`
     5. 시간적 응집도 ( Temporal Cohesion )
        - `특정 시간`에 `같이 처리`하는 모듈의 집합
     6. 논리적 응집도 ( Logical Cohesion )
        - `유사 성격` 혹은 `특정 형태`로 분류 되는 처리 요소로 `하나의 모듈이 형성`되는 경우
     7. 우연적 응집도 ( Coincidental Cohesion )
        - 서로 `관련 없는 요소`로만 구성된 경우

## 팬인 / 팬아웃

- 팬인
  - 어떤 `모듈이 제어`하는 모듈 수
  - 많으면 잘 설계됨
  - `간단히 부모수..?`
- 팬 아웃
  - 어떤 `모듈에 의해 제어`되는 모듈 수
  - 많으면 `단일 장애점` 발생 가능
    - `하나가 고장`나면 다 `마비`됨
  - `간단히 자식수..?`

## N- S차트(Nassi-Schneiderman Chart)

- 논리의 기술에 중점을 두고 도형으로 표현하는 방법
- 박스 다이어그램, Chapin chart라고도 부름
- `연속`, `선택 및 다중 선택`, `반복` 으로 `제어 논리 구조`로 표현
- `복합 조건`을 `시각적`으로 명확한 `식별`에 용이

# 단위 모듈

- `한 가지 동작`을 모듈로 구현한 것
- `독립적 컴파일가능`, 타 모듈에서 `호출 및 삽입`가능
- 구현 과정
  1.  단위 기능 명세서 작성
  2.  I/O 기능 구현
  3.  알고리즘 구현

## IPC ( Inter Process Comumunication )

- `모듈간 통신 방식을 구현을 위한 대표적인 인터페이스 집합`
- 대표적 메소드

  1.  Shared Memory
      - `공유 메모리`로 다수 프로세스간 통신
  2.  Socket
      - 소켓으로 네트워크를 경우하는 프로세스간 통신
  3.  Semaphores
      - `공유자원 접근제어`하여 통신
  4.  Pipes&names Pipes

      - FIFO형태의 메모리를 이용하여 프로세스 통신
      - Pipe는 `동시 접근 불가`

  5.  Message Queueing
      - 메시지 발생시 전달하는 방식

## 단위 모듈 테스트

- 모듈간 정해진 기능이 정확한 수행여부 검증
- 모듈 기준이기에 `시스템 수준의 오류는 검증 불가`

## 테스트 케이스

- SW가 요구사항에 정확히 준수하였는지 확인을 위한 명세서

- ISO/IEC/IEEE 29119-3표준 `구성 요소`
  1.  식별자 ( Identifier )
      - 항목, 식별자, 일련번호
  2.  테스트 항목 ( Test Item )
      - 테스트 대상
  3.  입력 명세 ( Input Specification )
      - 입력 데이터 혹은 테스트 조건
  4.  출력 명세 ( Output Specification )
      - 예상 출력 결과
  5.  환경 설정 ( Environmental Needs)
      - 필요 SW/HW 환경
  6.  특수 절차 요구 ( Special Procedure Requirement)
      - 특별히 요구되는 절차
  7.  의존성 기술 ( Inter-case Dependencies)
      - 테스트 케이스 간의 의존성

# 공통 모듈

- `여러 프로그램에서 공통으로 사용 가능한 모듈`
- 명세 기법 종류
  1.  정확성 ( correctness )
      - 구현시 기능의 필요성을 정확히 작성
  2.  명확성 ( Clarity )
      - 중의적 해석이 없도록 명확히 작성
  3.  완전성 ( Completness )
      - 구현시 필요한 모든것을 작성
  4.  일관성 ( Consistency )
      - 기능 상호간 충돌이 발생하지 않도록 작성
  5.  추적성 ( Traceability )
      - 관계를 파악할 수 있도록 작성

## 재사용

- 이미 개발된 기능들을 `새로운 시스템` 혹은 `기능 개발`에 사용하기 적합하도록 `최적화` 하는것
- 규모에 따른 분류
  1.  함수 및 객체
      - `클래스` 혹은 `메소드` 단위로 소스코드 재사용
  2.  컴포넌트
      - 인터페이스를 통해 통신하는 방법으로 재사용
  3.  어플리케이션
      - `공통 기능`을 제공하는 `APP을 공유`하는 방식으로 재사용

## 효과적인 모듈 설계 방안

1. `결합도`는 줄이고, `응집도`는 높인다
   - `독립성` 및 `재사용성` 향상
2. `복잡도` 및 `중복성` 줄인다
   - `일관성` 유지
3. 모듈의 기능은 예측 가능해야한다.
4. `모듈 크기`는 전반적 기능 및 `구조를 이해`하기 쉬운 크기로 분해
5. 모듈간 `계층적 관계`를 정의하는 자료가 제시되야함

# 코드

- 자료의 `분류` `조합` `집계` `추출`을 용이하기 위에 사용하는 기호

- 주요 기능

  1. 식별 기능

     - 데이터 성격에 따라 `분류`

  2. 분류 기능

     - 데이터를 `그룹화` 할 수 있어야함

  3. 배열 기능

     - 의미 부여하여 `나열` 가능

  4. 표준화 기능

     - 다양한 데이터를 `기준에 맞추어 표현`

  5. 간소화 기능

     - 복잡한 데이터 `간소화`

- 종류
  1.  순차 코드 (Sequence Code)
      - 순차적으로 일련번호를 부여하는 코드
        - `1,2,3,4,...`
  2.  블록 코드 ( Block Code )
      - 공통성이 있는 것을 블록으로 묶어 부여하는 코드
        - `학생 : 1001~10000`, `교수 : 1~1000`
  3.  10진 코드 ( Decimal Code ) (도서식 분류 코드)
      - 10진 분할 후 안에서 다시 10진 분할 하여 부여
        - `1000 : 공학`, `1100 : SW` ,`1110 : SW설계`
  4.  그룹 분류 코드 (Group Classification Code)
      - 대,중,소 분류 하여 구분하는 코드
        - `1-01-001 : 분교-학부-학과` , `2-01-001 : 본교-학부-학과`
  5.  연상 코드 ( Mnemonic Code )
      - 명칭, 약호등을 이용하여 부여하는 코드
        - `keyboard-87` : 87키 키보드
  6.  표의 숫자 코드 ( Significant Digit Code )
      - 물리적 수치로 부여하는 코드
        - `10-20-30 : 가로 세로 높이`
  7.  합성 코드 ( Combined Code )
      - 코드 2개 이상으로 조합하여 부여하는 코드

# 디자인 패턴

- 모듈 간의 `관계` 및 `인터페이스`를 설계할 때 참조할 수 있는 전형적인 해결 `방식 또는 예제`

## GOF의 디자인패턴

1. 생성 패턴 ( Creational Pattern )
   - `클래스 / 객체`의 `생성 및 참조` 과정 정의
   1. 추상 팩토리 ( Abstract Factory )
      - 인터페이스를 통해 `연관/의존` 하는 객체들을 그룹으로 묶어 `추상적으로 표현`
      - 연관된 서브 `클래스를 묶어` `한번에 교체 가능`
   2. 빌더 (Builder)
      - `인스턴스를 조합`하여 객체 생성
   3. 팩토리 메소드 (Factory Method ) ( 가상 생성자 )
      - 객체 생성을 캡슐화 한 패턴
      - 상위 클래스에 `인터페이스 정의`, 서브클래스에서 `사용`
   4. 프로토타입 (Prototype)
      - 원본 객체를 복제하여 사용
   5. 싱글톤 (Singleton)
      - `하나의 객체`에 `여러 프로세스`에서 `동시 참조`
2. 구조 패턴 ( Sturctual Pattern )

   - `클래스 및 객체`를 `조합`하여 `더 큰 구조`로 만드는 패턴

   1. 어댑터(Adapter )
      - 호환성이 없는 클래스의 인터페이스를 다른 클래스가 사용 할 수 있게 변환
      - 기존 클래스를 사용하고싶지만, 인터페이스가 일치하지 않을때 사용
   2. 브리지( Bridge )
      - `구현부에서 추상층`을 분리하여 `독립적 확장`을 가능하게 만듦
      - 기능 - 구현로 분리하여 클래스 구현
   3. 컴포지드 ( Composite )
      - `복합 객체` 및 `단일객체`를 구분없이 사용할 때 사용
      - `디렉토리 안에 디렉토리`와 유사한 구조
   4. 데코레이터 ( Decorator )
      - 객체간 결합을 통해 능동적으로 기능 확장
      - `임의의 객체`에 `부가적 기능`을 추가하기위에 `다른 객체를 덧붙임`
   5. 퍼싸더 ( Facade )
      - `서브 클래스`의 `상위 클래스`에 `인터페이스를 생성`하여 서브클래스 기능을 원활하게 만들어줌
   6. 플아이웨이트 ( Flyweight )
      - 인스턴스 필요시 생성이 아닌 공유를 하여 메모리 절약
      - `다수`의 유사 객체 `생성 및 조작`시 유용
   7. 프록시 ( Proxy )
      - 접근이 어려운 객체와 연결하려는 객체사이의 인터페이스 역할
      - `네트워크 연결`, `메모리의 대용량 객체`로 접근에 주로 이용

3. 행위 패턴 ( Behavioral Pattern )

   - `클래스 및 객체`들이 `상호작용`하는 방법 이나 `책임 분배` 방법을 정의하는 패턴

   1. 책임 연쇄 ( Chain of Responsibility)
      - `요청 처리 가능`한 객체가 `2이상`일때 `처리를 못` 하면 다음 객체로 넘어가는 형태
   2. 커맨드 ( Command )
      - 요청을 `객체 형태`로 `캡술화`하여 `재이용 혹은 취소` 할 수 있도록 `정보 저장 및 로그` 남기는 패턴
      - `추상 - 구체` 클래스 분리하여 단순화함
   3. 인터프리터 ( Interpreter)
      - 언어의 `문법 표현`을 `정의`
      - `sql` 혹은 `통신 프로토콜`등 개발시 사용
   4. 반복자 (Iterator)
      - 자료 구조처럼 접근이 많은 객체에 동일한 인터페이스 사용
      - 순차적 접근 가능
   5. 중재자 ( Mediator )

      - 객체간 `상호작용을 캡슐화`하여 객체로 정의
      - 객체간 `의존성이 낮아`지고, `결합도도 낮아`진다

   6. 메멘토 ( Memento )

      - `특정 시점의 객체 내부 상태`를 객체화하여 해당 `시점으로 돌릴` 수 있는 기능

   7. 옵저버 ( Observer )
      - 상위 객체가 변하면 `상속된 객체도` 변하는 패턴
      - 1:N 의존성
      - 분산 시스템에서 이벤트 발생 -> 수신시 이용
   8. 상태 ( State )
      - 상태에 따라 동일한 동작을 다르게 처리할때 사용
      - 객체 상태를 `캡슐화 후 참조`하는 방식
   9. 전략 (Strategy)
      - 동일계열 알고리즘을 개별적으로 캡슐화하여 상호 교환할 수 있는 패턴
      - 클라이언트가 원하는 알고리즘 선택 가능
   10. 템플릿 메소드 ( Template Method )
       - `상위에서 골격`, `하위에서 세부 처리`를 구체화 하는 구조
       - `코드양이 줄고`, `유지보수`가 용이해짐
   11. 방문자 ( Visitor )
       - 데이터 구조에서 `처리 기능을 분리`하여 별도의 클래스로 구성
       - 분리된 처리 기능은 각 클래스를 방문하여 수행

# 서버 개발

- 웹 어플리케이션의 로직을 구현시 서버 프로그램을 제작하여 WAS에 탑재하는 것

## 프레임워크

- 다양한 `네트워크 설정`, `요청 및 응답 처리`, `아키텍쳐 모델 구현` 등을 손쉽게 처리할 수 있도록 클래스나 인터페이스를 제공하는 SW
- 종류
  1.  Spring
      - `Java`기반 프레임워크
      - `전자정부 표준 프레임워크` 기반 기술로 사용
  2.  Node.js
      - `JavaScript` 기반 프레임워크
      - `비동기 입출력 처리` 및 `이벤트` 위주의 성능이 좋아 `실시간 입출력`이 빈번한 APP 에 적합
  3.  Django
      - `Python` 기반 프레임워크
      - `컴포넌트 재사용` 및 `플러그인화`를 강조
      - 신속한 개발 가능
  4.  Codeigniter
      - `PHP` 기반 프레임워크
      - `인터페이스가 간편`하고 서버 `자원을 적게` 사용
  5.  Ruby on Rails
      - `Ruby` 기반 프레임워크
      - `테스트 웹서버 지원` , `DB작업 단순화` 및 `자동화`하여 코드가 짧고, 신속한 개발 가능

## 개발 과정

- `DTO/VO , SQL, DAO, Service, Controller 구현`
- 구현 과정
  1.  DTO/VO (Data Transfer Object / Value Ovject ) 구현
      - 데이터 교환을 위한 `객체 생성`
      - `송/수신 데이터의 자료형`에 맞는 변수 및 객체 생성
  2.  SQL 구현
      - `CRUD` 를 수행할 SQL문 생성
      - 소스코드내에 직접 입력 혹은 XML 파일로 관리
  3.  DAO ( Data Acceess Object)구현
      - DB접근 및 SQL 활용하여 `실제 데이터 조작코드` 구현
  4.  Service 구현
      - `사용자 응답` 로직 구현
  5.  Controller 구현
      - `사용자 요청`에 관한 서비스 호출 후 결과를 반환하는 코드 구현

## 보안 및 API

- 보안 취약점을 최소화하여 안전한 SW 개발을 위한 보안활동
- 목표 : `기밀성`, `무결성`, `가용성` 등 `보안 요소`를 충족시키는 것
- 점검 항목

  1.  세션 통제
      - 세션 연결 및 연결로 인한 정보 관리
  2.  입력 데이터 검증 및 표현
      - 입력 데이터 유효성 검증체계를 갖추고, 검증 실패시 처리하도록 코딩
  3.  보안 기능
      - `인증`, `접근제어`, `기밀성`, `암호화`, 등
  4.  시간 및 상태
      - 다수의 프로세스가 동작하는 환경에서 시간과 실행 상태를 관리하여 시스템은 원활히 작동하도록 코딩
  5.  에러처리
      - 실행중 발생할 수 있는 오류를 사전에 정의하여 에러 방지
  6.  오류 코드
      - 형변환, 자원 반환등을 고려하여 코딩
  7.  캡슐화
      - 속성 및 데이터를 처리하는 함수를 하나의 객체로 묶는 것
  8.  API 오용
      - 보안에 취약한 API를 사용 혹은 오용하지 않을것

## API

- `라이브러리를 이용할 수 있도록 규칙 등을 정의해 놓은 인터페이스`
- `공개된 API` 즉 누구든 사용할 수 있는 API를 `OPEN API`라고한다
- 종류
  - Windows API
  - 단일 유닉스 규격 (SUS)
  - Java API
  - 웹 API

# 배치 프로그램

- 여러 작업들을 `미리 정해진 일련의 순서`에 따라 일괄적으로 처리하도록 만든 프로그램
- 필수 요소
  1.  대용량 데이터
      - 대용량 데이터 처리가 가능해야함
  2.  자동화
      - 심각한 오류를 제외하고 `사용자의 개입이 없어야함`
  3.  견고성
      - 잘못된 데이터 혹은 데이터 중복으로 `중단이 없어`야함
  4.  안정성/신뢰성
      - 오류 발생시 발생 `위치/시간`을 `추적` 할 수 있어야함
  5.  성능
      - 다른 응용프로그램을 `방해하지 말아야함`
      - `지정된 시간내`에 `처리`되야함

## 스케줄러 ( Batch Scheduler ) ( Job Scheduler)

- `일괄 처리 작업`이 설정된 주기에 맞춰 `자동`으로 `수행`되도록 지원해주는 도구
- 종류
  1.  스프링 배치 ( Spring Batch )
      - 오픈 소스 프레임워크
      - `로그 관리`, `추적`, `트랜잭션 관리`, `작업 처리 통계`, `작업 재시작` 등
  2.  Quartz
      - `Sping 프레임워크`로 개발되는 응용 프로그램들을 `일괄 처리`를 위한 `오픈 소스 라이브러리`
      - `수행할 작업 및 시간`을 관리하는 요소를 분리하여 `일괄 처리` 작업에 `유연성 제공`
  3.  Cron
      - 리눅스 기본 스케줄러
      - crontab 을 이용하여 예약가능
      - 예약 형식
        - `분, 시 , 일, 월 , 요일, 명령어`
        - `*`을 넣으면 모든 시간을 의미한다
        - `/`를 넣으면 시간을 나머지마다 실행한다
          - 3/ \* \* \* \* 명령어
            - 3분마다 명령어 실행

# 패키지 소프트웨어

- `기업`에서 `일반적으로 사용`하는 여러 `기능을 통합`하여 제공하는 SW
- `패키지 SW` 와 `전용 개발 SW`

|                | 패키지 소프트웨어                      | 전용 개발 소프트웨어          |
| -------------- | -------------------------------------- | ----------------------------- |
| 기능 요구 사항 | 70%이상 충족시키는 SW가 있는 경우 이용 | 모든 기능 요구사항 반영 가능  |
| 안정성         | 품질 점증되어있고, 업계 표준           | 개발자 역량                   |
| 라이센스       | 판매자                                 | 회사                          |
| 생산성         | 개발을 위한 `인력및 시간 절약`         | 개발을 위한 인력 및 시간 필요 |
| 호환선         | `보장 안됨`                            | `설계 단계`부터 고려하여 개발 |
| 유지보수       | 즉시 대응이 어려움                     | 즉시 대응 가능                |

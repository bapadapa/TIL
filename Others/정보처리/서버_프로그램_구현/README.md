# 서버 프로그램 구현

## 개발환경 구축

- 개발 프로젝트를 이해하고 `SW/HW 장비`를 구축하는 것
- 개발 환경은 실제로 `운영될 환경`과 `유사한 구조`로 구축
- `분석 단계의 산출물을 바탕`으로 개발에 필요한 `SW/HW 를 선정`
- 비지니스 환경에 적합한 제품들을 결정하여 구축

## HW 환경

- 클라이언트 - 서버 로 구성
- 종류 : PC, 스마트폰 ,테블릿 , 등
- 종류
  1. 웹 서버 (Web Server)
     - 클라이언트로부터 작업을 받아 처리
     - 저용량 정적 파일 제공
       - 정적 파일 : 추가 가공이 필요 없는 파일
  2. 웹 어플리케이션 서버 (WAS)
     - 동적 서비스 제공
     - WEB/DB/FILE 서버 사이의 `인터페이스 역할` 수행
  3. 데이터베이스 서버 (DB Sever)
     - DB관리하는 DBMS 운용
  4. 파일 서버 (File Server)
     - `DB에 저장`하기엔 `비효율`이거나 `서비스 제공 목적`인 파일들을 저장

## SW 환경

- 클라이언트/ 서버 운영 및 개발에 사용되는 SW로 구성
- 시스템 SW 종류 : `OS`, `WAS`, `DBMS`....
- 개발 SW 종류

  1. 요구사항 관리도구
     - `수집/분석/추적`등을 도와주는 소프트웨어
  2. 설게/모델링 도구
     - `UML`을 지원하며, `개발 전 과정`에서 `설계 및 모델링`을 도와주는 SW
  3. 구현 도구
     - 실제 개발을 하는 SW
  4. 빌드 도구
     - `빌드/배포/라이브러리` 관리 등을 지원하는 SW
  5. 테스트 도구

     - 요구사항에 적합하게 구현하였는지 테스트하는 SW

  6. 형상 관리 도구
     - 버전 관리를 하여 품질 향상을 지원하는 SW

## 웹 서버 기능

1. HTTP/HTTPS 지원
   - 브라우저 요청 응답시 사용하는 프로토콜
2. 통신 기록 (Comunication Log)
   - 처리한 요청을 `로그 파일로 기록`
3. 정적 파일 관리 (Managing Static Files)
   - 정적 파일 `저장 관리`
4. 대역폭 제한(Bandwidth Throttling)
   - 트래픽 포화를 방지하기 위해 응답 속도 제한
5. 가상 호스팅 (Virtual Hosting)
   - `1개 서버`를 `여러개 도메인 명`으로 연결
6. 인증(Authentication)
   - 사용자 확인 기능

## 개발 언어 선정 기준

1. 적정성
   - 목적이 적합한가
2. 효율성
   - 개발이 효율적인가
3. 이식성
   - `다양한 시스템/환경`에 적용이 가능한가
4. 친밀성
   - 개발자의 `이해도` 및 `활용도`가 높은가
5. 범용성
   - `개발 사례`가 있고, `여러 분야에서 활용`되는가

# 소프트웨어 아키텍처

- 소프트웨어를 구성하는 `요소들 간의 관계`를 표현하는 `시스템의 구조` 또는 `구조체`
- 어플리케이션 분할방법 및 분할된 모듈에 `할당될 기능`, `모듈간 인터페이스` 등을 결정
- 기본 원리

  1. 모듈화
     - `수정`, `재사용`, `유지관리` 등을 위해 시스템의 기능들을 `모듈 단위`로 나누는 것
       - 모듈 : `특정 기능을 처리`할 수 있는 코드
     - 모듈을 너무 `세분화`하여 나누면 `통합 비용`이 많이 든다.
     - 모듈 크기가 크면 `통합비용은 낮아`지지만, `모듈 개발 비용이 많이` 든다.
  2. 추상화

     - 전체적 개념을 설계 후 구체화 시켜나가는 것
     - 시스템 구축 전에 테스트 해볼 수 있다.
     - 유형
       1. 과정 추상화
          - `흐름만 파악`할 수 있게 설계하는 방법
       2. 데이터 추상화
          - 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
       3. 제어 추상화
          - 여러개의 기계어 명령들을 간단히 요약한 것

  3. 단계적 분해
     - `상위의 중요 개념`에서 `하위의 개념으로 구체화` 시키는 기법
  4. 정보 은닉
     - 모듈 내부에 포함된 절차 및 자료들의 정보에 다른 모듈이 `접근/변경`을 `방지`하는 기법
     - 변경시 다른 모듈에 영향을 미치지 않아 `수정/시험/유지보수`가 용이

## 상위 설계 및 하위 설계

- 상위 설계
  - 별칭 : 아키텍처/ 예비 설계
  - 대상 : SYS의 전체적 구조
  - 세부 목록 : 구조, DB, 인터페이스
- 하위 설계
  - 별칭 : 모듈/상세 설계
  - 대상 : 시스템 내부 구조 및 행위
  - 세부 목록 : 컴포넌트, 자료구조, 알고리즘

## 품질 속성

- SW아키텍쳐가 요구 수준의 품질을 유지/보장 할 수 있게 설계되었는지 확인하는 요소들
- 종류
  1. 시스템 측면
     - `성능`, `보안`, `가용성`, `사용성`, `변경 용이성`, `확장성` ...
  2. 비니지스 측면
     - `시장 적시성`, `비용과 혜택`, `예상 시스템 수명`, `목표시장`, `공개 일정` ...
  3. 아키텍쳐 측면
     - `개념적 무결성`, `정확성`, `완결성`, `구축 가능성`, `변경성`, `시험성` ...

## 설계 과정

1. 설계 목표 설정
   - 요구사항 분석 후 전체 시스템 설계 목표 설정
2. 시스템 타입 결정
   - `시스템/서브시스템` 타입 결정 후 `아키택처 패턴 선택`
3. 아키텍처 패턴 적용
   - 시스템 표준 아키텍처 설계
4. 서브시스템 구체화
   - `서브시스템 기능` 및 `상호작용`을 위한 동작 인터페이스 정의
5. 검토
   - `설계 목표`, `요구사항`, `기본 원리` 등을 만족여부 검토

## 협약에 의한 설계

- `컴포넌트 설계`시 클래스에 대한 여러 가정을 `공유` 할 수 있도록 명세
- 조건
  1. 선행 조건(Precondition)
     - 오퍼레이션 `호출 전 참(True)`이 되야할 조건
  2. 결과 조건(Postcondition)
     - 오퍼레이션 `수행 후 만족`해야할 조건
  3. 불변 조건(Invariant)
     - 오퍼레이션 `실행중 만족`해야할 조건

# 아키텍처 패턴

- 아키텍쳐 `설계시 참조`할 수 있는 전형적인 `해결 방식` 혹은 `예제`
- 종류

  1. 레이어 패턴 (Layers Pattern)

     - 시스템을 `계층 구분`하여 구성하는 고전적 패턴
     - `상위 : 서비스 제공자` , `하위 : 클라이언트`
     - 인접 계층만 상호작용 발생
     - 대표 : OSI 참조 모델

  2. 클라이언트-서버 패턴 (Client-Server Pattern)
     - `1개의 서버` 컴포넌트, `다수의 클라이언트` 컴포넌트로 구성된 패턴
       - 1:N구조
     - `사용자` -> `클라이언트` -> `서버` -> `클라이언트` -> `사용자` 순으로 요청이 이루어짐
  3. 파이프-필터 패턴(Pipe-Filter Pattern)
     - `데이터 스트림 절차`의 단계를 `필터로 캡슐화`하여 `파이프를 통해 전송`하는 패턴
     - `데이터 변환`, `버퍼링`, `동기화` 등에 주로 사용
     - 대표 : UNIX SHELL
     - source `-pipe->` filter `-pipe->` fileter `-pipe->` sink
  4. MVC 패턴 (Model-View-Controller Pattern)

     - 서브시스템을 MVC로 구조화 하는 패턴
     - `컨트롤러` : 사용자 요청 받기
       - `INPUT / 제어 / 갱신`
     - `모델` : 핵심 기능 및 인계받은 데이터 보관
       - `저장 / 변경 알림`
     - `뷰` : 정보 출력
       - `OUTPUT / 정보 요청`
       - 여러개 생성 가능
     - 모델 1 : 뷰 n개 의 `대화형 APP`에 적합하다.

  5. 마스터 슬레이브 패턴 ( Master Slave Pattern)
     - 슬레이브에서 처리된 결과를 다시 돌려받는 방식으로 수행하는 패턴
       - `장애 허용 시스템`, `병렬 컴퓨팅 시스템`
  6. 브로커 패턴 ( Broker Pattern )
     - `사용자 요구`를 브로커 컴포넌트에 `요청시` 그에 맞는 `컴포넌트와 연결`해주는 패턴
       - 분산 환경 시스템
  7. P2P 패턴 (Peer to Peer Pattern)
     - 각 컴포넌트가 서버가 될 수 있고, 클라이언트가 될 수 있는 패턴
       - 파일 공유 네트워크
  8. 이벤트 버스 패턴 ( Event Bus Pattern)
     - 채널을 구독한 리스너들이 메시지를 받아 이벤트 처리하는 패턴
       - 알람 서비스
  9. 블랙보드 패턴 (Blackboard Pattern )
     - `모든 컴포넌트`가 `공유 데이터 저장소` 및 `블랙보드 컴포넌트`에 `접근 가능`한 패턴
       - 음성 인식, 차량 식별, 신호 해석
  10. 인터프리터 패턴 (Interpreter Pattern)

      - 코드의 각 라인을 수행하는 방법 지정 및 기호마다 클래스를 갖도록 구성된 패턴
        - 번역기, 컴파일러, 인터프리터

# 객체 지향 (Object Oriented)

- `객체 생성` 후 `객체를 조립`하여 SW 를 개발하는 기법
- `재사용성` 및 `확장`이 용이하여 SW를 `개발` 및 `유지보수`가 쉽다
- 구성요소
  1. 객체 (Object)
     - 데이터 및 함수를 묶어놓은 SW 모듈
       - 데이터 : 객체의 `정보` / `속성` / `상태` / `분류`...
       - 함수 : 데이터 처리하는 `알고리즘` 및 객체 상태 `참조` 및 `변경`하는 수단
  2. 클래스(class)
     - 공통된 `속성` 및 `연산`을 갖는 객체 집합
     - 클래스 내부의 객체를 `인스턴스`라고 부른다
  3. 메시지(message)
     - 객체간 `상호작용에 사용`되는 수단, 객체의 `동작` 및 `연산`을 발생시키는 `외부의 요구` 사항
- 특징
  1. 캡슐화(Encapsulation)
     - 외부 접근을 제한하기 위해 인터페이스를 제외한 `세부 내용을 은닉`하는 것
     - `인터페이스가 단순`해지고, 객체간 `결합도가 낮아`진다.
  2. 상속(Inheritance)
     - 상위 클래스를 하위 클래스가 물려받는 것
  3. 다형성(Polymorphism)
     - 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력
     - 객체는 `동일 메소드명` , `동일 의미의 응답`
  4. 연관성(Relationship)
     - 2개 이상의 객체가 상호 참조하는 관계
     - 종류
       1. is member of
          - 연관화(Association)
          - 2개 이상의 객체가 상호 관련됨
       2. is instance of
          - 분류화(Classfication)
          - `동일형의 특성`으로 객체를 모아 구성
       3. is part of
          - 집단화(Aggregation)
          - `관련된 객체`를 묶어 상위 객체를 구성
       4. is a
          - 일반화(Generalization)
            - `공통 성질`로 `추상화`하여 상위 객체 구성
          - 특수/상세화(Specialization)
            - `상위 객체`를 구체화 하여 `하위 객체를 구성`

## 분석 및 설계

### 객체지향 분석 OOA

- `사용자 요구사항`과 관련된 `객체`, `속성`, `연산`, `관계` 등을 정의하여 모델링
- `객체-속성`, `클래스-멤버`, `전체-부분` 등으로 나누어 분석
- 클래스 식별이 목적

#### 방법론

1. Rumbaugh 방법 (OMT (Object-Modeling Technique) 라고조 부름)
   - `객체`, `동적` , `기능` 모델로 나누어 분석 활동을 함
   - 모든 `SW 구성 요소`를 `그래픽 표기법`을 이용하여 모델링함
   - 활동 순서
     1. 객체 모델링 <정보 모델링>
        - `속성`, `연산 식별` 및 `객체들 간의 관계`를 `객체 다이어그램`으로 표시
     2. 동적 모델링
        - 시간의 흐름에 따라 `동적인 행위`를 `상태 다이어그램`을 이용하여 표현
     3. 기능 모델링
        - 프로세스간 자료흐름 중심으로 `처리과정`을 `DFD(자료흐름도)`를 이용하요 표현
2. Booch 방법
   - `미시/거시적 개발 프로세스` 모두 사용
   - `클래스/객체` 를 분석 및 식별 및 클래스 `속성,연산`을 정의
3. Jacobson 방법
   - `유스케이스`를 강조하여 사용
4. Coad & Yourdon 방법
   - `E-R다이어그램`을 사용하여 `객체 행위 모델링`함
   - `객체 식별`, `구조 식별` ,`주제 정의`, `속성 및 인스턴스 연결 정의`, `연산 및 메시지 연결 정의` 등의 과정
5. Wirfs-Brock 방법
   - `분석과 설계간 구분이 없고` 고객 `명세서를 평가`하여 `설계 작업까지 연속적`으로 수행

### 설계 원칙

- `변경` 혹은 `확장`에 `유연한 시스템`을 `설계`하기 위해 지켜야할 원칙
- 5가지 원칙의 앞글자를따 SOLID원칙이라 부른다
  1. 단일 책임 원칙(SRP)
     - 객체는 1개의 책임만 가져야한다
  2. 개방-폐쇄 원칙(OCP)
     - `코드의 변경 없이 기능 추가`가 가능해야한다
  3. 리스코프 치환 원칙(LSP)
     - 자식 클래스는 부모 클래스의 기능을 수행 할 수 있어야한다
  4. 인터페이스 분리 원칙(ISP)
     - `사용하지 않은 인터페이스`와 `의존관계 혹은 영향을 받지 않아야한다`
  5. 의존 역전 원칙(DIP)
     - 의존 관계 성립 시 `추상성이 높은 클래스`와 `의존 관계`를 맺어야 한다.

# 인덱스

- 데이터 레코드를 빠르게 접근하기 위해 `<Key - Pointer>`쌍으로 구성되어 있는 데이터 구조
- `물리적 주소에 접근` 방법을 제공
- `삽입 삭제가 빈번`하면, `Index` 개수를 `최소`로 하는 것이 좋다.

## 종류

1. 트리 기반 인덱스
   - 저장 블록들이 트리구조인 것
2. 비트맵 인덱스
   - 인덱스 칼럼의 데이터를 Bit로 변환하여 인덱스 키 사용
3. 함수 기반 인덱스
   - 값 대신 함수 혹은 수식을 적용하여 산출된 값 사용
4. 비트맵 조인 인덱스
   - 다수의 조인된 객체로 구성된 인덱스
5. 도메인 인덱스
   - 개발자가 직접 만들어 사용하는 인덱스

## 클러스터드/넌클러스터드 인덱스( Clustered/Non-Clustered Index)

- 클러스터드 ( Clustered Index)
  1. `인덱스 키`의 순서에 따라 `정렬`되어있음
  2. `실제 데이터가 정렬`되어 있어 인덱스 검색이 아니라도 빠르게 검색 가능
- 넌 클러스터드( Non- Clustered Index)
  1. `인덱스 키만 정렬` 되어있지만, `실제 데이터는 정렬되어 있지 않음`
  2. `삽입/삭제` 발생시 순서를 위해 `재정렬`해야함

# 뷰 (View)

- 사용자에게 `제한된 정보`를 보여주기 위해 `기본 테이블로부터 유도`된 이름을 가지는 `가상테이블`
- 물리적으로 존재하지 않지만, 물리적으로 존재하는 것 처럼 사용자에게 간주됨
- 뷰를 사용한다면, 뷰에 나타나지 않은 데이터를 안전하게 보호할 수 있다.
- 기본적으로 뷰 삭제시 자식 뷰는 `연쇄적으로 삭제`된다.
- 생성시 `CREATE`, 삭제시 `DROP` 문을 사용한다.

## 장/단점

- 장점
  1. 논리적 데이터 `독립성` 제공
  2. 여러 사용자가 `상이한 권한 부여` 가능
  3. 사용자 `데이터 관리가 간단`해짐
  4. `접근 제어`를 통해 `보안이 강화`됨
- 단점
  1. `독립적 인덱스` 부여가 `불가능`
  2. `정의 변경이 불가`하다.
  3. 뷰로 구성된 내용에 `CRUD 연산에 제약`이 있다.

## 클러스터 (Cluster)

- `동일한 성격의 데이터`를 `동일한 블록`에 `저장`하는 물리적 저장방법
- `조회` 속도는 향상되지만, `입력/수정/삭제`가 느려진다.
- 데이터 분포도가 넓으면 유리하다.
  - 데이터 분포도
    - `조회수`/`전체 데이터` \* `100`
    - 낮으면 분포도가 좋음
- 분포도가 넓을 시 클러스터링시 `저장 공간 절약`
- `범위가 넓을`경우 `단일 테이블 클러스터링`을 한다
- `조인을 많이` 할 시 `다중 테이블 클러스터링`을 사용

# 파티션 ( Partition )

- `대용량` 테이블 혹은 인덱스 등을 작은 `논리적 단위`인 파티션으로 `나누는 것`.
- 파티션을 나누면 `성능 저하 방지` 및 `데이터 관리가 용이`해짐
- 처리는 데이터 단위, 저장은 파티션단위로 수행

## 장단점

- 장점
  1. 액세스 범위가 줄어서 `쿼리 성능 향상`
  2. 디스크 성능 향상
  3. `백업` 및 `복구` 속도가 `빠름`
  4. 데이터 `손상 최소화` ( 데이터가 분산되어 있기 때문 )
  5. 데이터 `가용성 향상`
  6. `입/출력을 분산`시킬 수 있다.
- 단점
  1. 세분화 하여, `세심한 관리`가 필요
  2. `조인 비용이 증가함`
  3. 필요 이상의 파티셔닝은 오히려 성능 저하됨

## 종류

1. 범위 분할 ( Range partitioning )
   - 지정된 열값을 준으로 분할
     - EX\_기간별
2. 해시 분할 ( Hash partitioning )

   - 해시 함수 적용 결과에 따라 데이터 분할
   - 데이터가 고르게 분산 할 때 유용함
   - 데이터의 `순서가 없어` 위치를 알 수 없다.
   - `데이터가 고른 칼럼`에 효과적임

3. 조합 분할 ( Composite partitioning )
   - `범위 분할` 후 `해시 함수`적용 후 `다시 분할`하는 방식
   - 파티션이 너무 `방대해 관리가 어려울때` 용이

# 분산 DB 설계

- `논리적으로 하나`의 시스템에 속하지만 `물리적으로는 네트워크`를 통해 연결된 여러 개의 사이트에 `분산된 DB`를 지칭한다.
- 지역으로 분산시켜 `사용이 많은 지역`에 DB를 위치시켜 데이터 처리를 `그 지역에서 처리`할 수 있도록한다.
- 분산 DB 설계는 `APP 및 사용자`가 `분산되어 접근`하는 것이 목적이다.

## 분산 DB의 목표

1.  위치 투명성 (Location Transparency)

    - DB의 위치를 알 필요없이 논리적인 명칭만으로 액세스 할 수 있다.

2.  중복 투명성 ( Replication Transparency)

    - `중복 데이터`가 있더라도 `하나의 데이터`만 있는 것 처럼 사용하고, 시스템은 `자동으로 여러 자료에 대한 작업 수행`

3.  병행 투명성 ( Concurrency Transparency )
    - `동시 다발적 트랜젝션`이 실현되도, 각 트랜잭션의 `결과는 영향을 받지 않는다`.
4.  장애 투명성 ( Failure Transparency )
    - 각종 장애가 발생해도, 트랜잭션은 정확히 처리한다.

## 분산 설계 방법

1. 테이블 위치 분산
   - 테이블을 각기 다른 서버에 `분산 배치`함
2. 분할 ( Fragmentation )

   - 테이블 데이터를 `분할 분산`시킴
   - 분할 규칙
     - 완전성 (completeness) , 재구성( Reconstruction), 상호 중첩 배제( Disjointness )
   - 분할방법
     1. 수평 분할
        - 특정 `속성 기준`으로 `Row 단위` 분할
     2. 수직 분할
        - `속성(칼럼)` 단위로 분할

3. 할당 ( Allocation )
   - 동일한 분할을 여러 서ㅡ버에 생성
   - `중복 유무`에 따른 할당으로 나뉨

## 용양 설계

- 설계시 `데이터양`,`인덱스`,`클러스터` 등 `공간을 예측`하여 설계하는 것
- 목적
  - `정확히 산정`하면, `공간 효율이 증대`하고, `확장성` 및 `가용성`이 높아진다.
  - 디스크 특성을 고려하여 설계하면 데이터 입출력 `부하를 분산` 및 채널의 `병목 현상 최소화`한다.

# 데이터 베이스 이중화 (DB Replication)

- `동일한 DB를 복제`하여 관리
  - 오류로 인한 장애 방지
  - 손쉽게 백업 서버 운영할 가능
- 분산 처리하여 `DB 부하가 감소`.

## 이중화 분류

1. EAGER 기법
   - 변경 발생시 모든 DB에 즉시 변경내용 적용
2. LAZY 기법
   - 트랜잭션 `종료시` `새로운 트랜잭션을 작성`하여 새로운 사실을 DB에 전달.
   - DB마다 새로운 트랜잭션이 수행되는 것으로 간주

## 이중화 구성 방법

1. 활동-대기 방법
   - 한 DB에서 발생하면, 대기중이던 DB가 자동으로 서비스 수행
   - `구성` 및 `관리`가 용이함
2. 활동-활동 방법
   - 서로 다른 서비스를 제공하다, `한 DB에서 장애 발생`시 `나머지 DB`에서 모든 `작업 수행`
   - `처리 효율`은 높지만, `구성 및 설정`이 어려움

## 클러스터링 ( Clustering )

- `2대 이상`의 서버를 `하나의 서버처럼` 운영하는 기술
- `이중화`, `공유 스토리지`를 통해 서버의 `고가용성`을
  제공

### 종류

1. 고가용성 클러스터링
   - 하나의 서버가 장애 발생시 다른 노드가 처리함.
   - 일반적으로 언급되는 고가용성 클러스터링
2. 병렬 처리 클러스터링
   - `처리율을 향상`시키기 위해 `여러 서버`로 `분산처리`하는 방식

### RTO/PRO

1. RTO ( Recover Time Objective )

   - 목표 복구 시간
   - 문제 발생으로 `업무 중단 시점` 복구 후 `가동될때`까지의 `소요 시간`
   - `업무 복구 위주 `

2. PRO ( Recovery Point Object )
   - 문제 발생 시점부터 `데이터 복구`를 할 수 있는 시간
   - `데이터 복구 위주`

# DB 보안

- 사용자에게 권한을 부여하여 DB 엑세스에 제한을 두는 기술

## 암호화

- 평문을 `송/수신자만` 알 수 있도록 암호문으로 변경시킨 것
- 암호화(Encryption) 과정
  - `평문`을 `암호문`로 변환 시키는 과정
- 복호화(Decryption) 과정
  - `암호문`을 `평문`으로 변환시키는 과정
- 기법
  - 개인키 암호화 방식( Private Key Encryption )
  - 공개키 암오화 방식( Public Key Encryption )

## 접근통제

- 객체와 주체 사이의 `정보 흐름을 제한`하는 것
  - 객체 : DB개체들
  - 주체 : 객체에 접근하려는 `사용자` 및 `시스템`

## 접근 3요소

### 접근 통제 (1) 정책

- 정책
  1.  임의 접근 통제( DAC , Discretionary Accecss Control)
      1. `사용자 신원`에 따라 권한 부여
      2. `소유자가` 모든 권한 제어
  2.  강제 접근 통제( MAC, Mandatory Access Control)
      1. 주체 및 객체의 `등급에 따라 권한` 부여
      2. `시스템이 접근통제` 권한 지정
      3. `DB 개체별`로 보안 등급 부여
      4. `사용자별 인가` 등급 부여
  3.  역할기반 접근통제 ( RBAC, Role Based Access Control)
      1. `역할에 따라` 접근 권한 부여
      2. `중앙관리자`가 접근 통제
      3. `임의/강제 접근 통제`의 단점을 보완함
      4. `다중 프로그래밍` 환경에 최적화됨

### 접근통제 정책

- `누가` `언제` `어디서` `무엇` `어떻게` 에 대한 허용 여부를 정의한 것
- 종류

  1.  신분 기반 정책

      - 주체 혹은 그룹의 신분에 의해 접근 제한한다.
        - `IBP` 및 `GBP`가 있다.
      - IBP(Individual-Based Policy)
        - 최소한의 권한, `단일주체`에게 `하나의 객체`에 대한 허가를 부여
        - 즉, 최소한의 권한을 1:1 (주체:객체)로 부여
      - GBP(Group-Based Policy)
        - `복수 주체`에 `하나의 객체`에 대한 허가
        - 즉, `그룹`에 `객체 1개`의 접근 권한을 부여

  2.  규할 기반 정책

      - 주체의 권한에 따라 접근제한
        - `MLP` 및 `CBP`가 있다.
      - MLP ( Multi-Level Policy)
        - 개인별 지정된 기밀 분류에 따른 정책
      - CBP(Compartment-Based Policy)
        - 집단별 지정된 기밀 허가에 따른 정책

  3.  역할 기반 정책
      - `GBP` 변형 정책, 주체의 역할에 따라 객체 접근을 제한

### 접근통제 (2) 메커니즘

- 정의된 접근통제 정책을 구현하는 기술적인 방법
- `접근통제 목록`, `능력 리스트`, `보안 등급` , `패스워드`, `암호화` 등이 있다.
  - 접근통제 목록
    - 주체가 할 수 있는 행위를 기록한 목록
  - 능력 리스트
    - 주체에 허가된 `자원` 및 `권한`을 기록한 목록

### 접근통제 (3) 보안모델

- 보안 정책을 구현하기 위한 `정형화된 모델`
- 모델 종류
  1.  기밀성 모델
      1. 군사목적인 최초의 `수학적 모델`
      2. `기밀성 보장`이 최우선
      3. `특수 환경`에서 주로 사용
  2.  무결성 모델
      1. `기밀성 모델`에서 발생하는 `불법적 정보 변경 방지`를 위해 `무결성 기반`으로 만들어진 모델
  3.  접근통제 모델
      1. `접근 통제 메커니즘`을 `보안 모델`로 발전시킨 것
      2. 대표 모델
         - 접근 통제 행렬( Access Control Matrix)
           - 임의적 접근통제 관리를 위해 `행은 주체`, `열은 객체`로써 객체 권한 유형을 나타내는 모델

## 접근 통제 조건

- 접근통제 메커니즘의 취약점 보안을 위해 접근통제 정책에 부가하여 적용할 수 있는 조건

1. 값 종속 통제( Value-Dependent Control )
   - 객체에 `저장된 값`에 따라 `다른 접근통제`를 허용하는 경우 사용
2. 다중 사용자 통제(Multi-User Control)
   - `다수의 사용자`가 `동시 접근요구시` 사용
3. 컨텍스트 기반 통제(Context-Based Control)
   - `시간`, `네트워크 주소`, `접근 경로`, `인증 수준`에 따라 접근 제어
   - `다른 정책과 결합`하여 `취약점 보완`시 사용

## 감사 추적

- 수행한 모든 활동 기록 ( Log ? )
- `오류 복구` 및 `부적절한 데이터 조작`을 파악을 위해 사용

# DB 백업 (BackUp)

- 예상치 못한 오류를 대비해 `보호` 및 `복구`하기 위한 작업
- 데이터 손실을 막기 위해 `정기적으로 백업`을 해야한다

## 로그 파일 ( Log File )

- DB 의 상태 변화를 `시간에 따라` 모든 것을 `기록한 파일`
- 복구에 기반이 되는 파일
- `과거 상태 복귀`(UnDo) 및 `현재 상태로 재생`(ReDo)하여 `일관성` 있게 유지할 수 있다
- `트랜잭션` 시작 시점, `롤백` 시점, `CRUD` 시점 등에서 기록된다.

## 복구 알고리즘

1. No-UNDO / REDO
   1. `비동기적으로 갱신`시 사용
   2. No-UNDO
      - 트랜잭션 완류 후 DB기록된다.
   3. REDO
      - 트랜잭션 완료후 `DB버퍼에 기록` 되지만, `저장 매체에는 기록되지 않는다`.
2. UNDO/NO-REDO
   1. `동기적으로 갱신`시 사용
   2. UNDO
      - `시스템 파손`시 변경내용 취소
   3. NO-REDO
      - 트랜잭션 완료 후 저장매체에 저장함
3. UNDO/REDO
   1. `동기/비동기 갱신`시 사용
   2. 기록 전에 트랜잭션이 완료될 수 있다.
4. NO-UNDO/No-REDO
   1. `동기적으로 기록`하지만, `다른 영역에 기록`한 경우 사용
   2. NO-UNDO
      - 다른 영역에 기록됨
   3. No-REDO
      - 다른 영역에 기록됨

## 백업 종류

- 복구 수준에 따라 아래 2개의 백업이 있다.

1. 물리 백업
   - DB 파일을 백업
   - 속도가 `빠르고` `단순함`
   - 문제 발생시 `원인 파악이 어렵다`
2. 논리 백업
   - 논리 객체로 백업
   - `손상이 적고`, `원인 파악` 및 `해결`이 수월함
   - 복원/백업 `시간이 오래 걸린다`.

# 스토리지

- 대용량의 데이터를 저장을 위해 서버와 저장장치를 연결하는 기술

## 종류

1. DAS( Direct Attached Storage )
   - 서버와 전용 케이블로 직접 연결한 방식
   - 외장 하드를 연결하는것
   - `구축` 및 `유지보수` 비용이 `저렴`하다
   - 다른 서버에서 `접근` 및 `파일공유`가 어렵다
   - `확장성` 및 `유연성`이 떨어짐
2. NAS( Network Attached Storage )
   - 서버와 저장장치를 네트워트로 연결하는 것
   - Ethernet 스위치를 통해 다른 서버에서도 `접근` 및 `파일 공유`가 `용이`하다
   - DAS대비 `확장성` 및 `유연성`이 용이
3. SAN( Storage Area Network )
   - DAS + NAS 방식
   - `서버 및 저장장치를 연결` 후 `전용 네트워크를 별도로 구성`하는 방식
   - `파이버 체널 스위치`를 이용해 구성
   - 광케이블로 연결하여 처리 속도가 빠르다
   - DAS 및 NAS 의 장점을 가지고 있다.
